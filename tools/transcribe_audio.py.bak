#!/usr/bin/env python3
"""
转录音频文件
支持 OGG/Opus 格式，转换为 WAV 后使用 vosk 识别
"""

import os
import sys
import subprocess
import tempfile
import json
from pathlib import Path

def convert_ogg_to_wav(ogg_path: str, wav_path: str = None) -> str:
    """将 OGG/Opus 转换为 WAV 格式"""
    if wav_path is None:
        # 创建临时文件
        wav_path = tempfile.mktemp(suffix='.wav')
    
    try:
        # 使用 ffmpeg 转换
        cmd = [
            'ffmpeg',
            '-i', ogg_path,
            '-ar', '16000',      # 采样率 16kHz
            '-ac', '1',          # 单声道
            '-acodec', 'pcm_s16le',  # 16-bit PCM
            '-y',                # 覆盖输出文件
            wav_path
        ]
        
        print(f"转换音频: {ogg_path} -> {wav_path}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        if result.returncode != 0:
            print(f"转换失败: {result.stderr}")
            return None
        
        # 检查输出文件
        if os.path.exists(wav_path) and os.path.getsize(wav_path) > 0:
            print(f"转换成功，文件大小: {os.path.getsize(wav_path)} bytes")
            return wav_path
        else:
            print("转换失败：输出文件为空或不存在")
            return None
            
    except FileNotFoundError:
        print("错误: ffmpeg 未安装")
        print("请安装 ffmpeg: winget install ffmpeg")
        return None
    except Exception as e:
        print(f"转换过程中出错: {e}")
        return None

def transcribe_audio(audio_path: str, model_path: str = None) -> str:
    """使用 vosk 转录音频"""
    try:
        from vosk import Model, KaldiRecognizer
        import wave
        import json
    except ImportError:
        print("错误: vosk 未安装")
        print("请运行: pip install vosk")
        return None
    
    # 设置模型路径
    if model_path is None:
        model_path = r"C:\Users\A\.openclaw\models\vosk-cn"
    
    # 检查模型
    if not os.path.exists(model_path):
        print(f"错误: 模型路径不存在: {model_path}")
        return None
    
    try:
        # 加载模型
        print(f"加载语音模型: {model_path}")
        model = Model(model_path)
        
        # 打开音频文件
        print(f"打开音频文件: {audio_path}")
        wf = wave.open(audio_path, "rb")
        
        # 检查音频格式
        if wf.getnchannels() != 1:
            print("警告: 音频不是单声道，可能影响识别精度")
        if wf.getsampwidth() != 2:
            print("警告: 音频不是16-bit，可能影响识别精度")
        if wf.getframerate() != 16000:
            print(f"警告: 采样率不是16000Hz (当前: {wf.getframerate()}Hz)")
        
        # 创建识别器
        rec = KaldiRecognizer(model, wf.getframerate())
        
        # 识别音频
        print("开始语音识别...")
        text_parts = []
        
        while True:
            data = wf.readframes(4000)
            if len(data) == 0:
                break
            
            if rec.AcceptWaveform(data):
                result = json.loads(rec.Result())
                if result.get("text"):
                    text_parts.append(result["text"])
        
        # 获取最终结果
        final_result = json.loads(rec.FinalResult())
        if final_result.get("text"):
            text_parts.append(final_result["text"])
        
        wf.close()
        
        # 合并结果
        full_text = " ".join(text_parts).strip()
        
        if full_text:
            print(f"识别结果: '{full_text}'")
            return full_text
        else:
            print("识别结果为空")
            return None
            
    except Exception as e:
        print(f"语音识别过程中出错: {e}")
        import traceback
        traceback.print_exc()
        return None

def main():
    """主函数"""
    if len(sys.argv) < 2:
        print("用法: python transcribe_audio.py <音频文件路径>")
        print("示例: python transcribe_audio.py audio.ogg")
        sys.exit(1)
    
    audio_path = sys.argv[1]
    
    if not os.path.exists(audio_path):
        print(f"错误: 文件不存在: {audio_path}")
        sys.exit(1)
    
    print(f"处理音频文件: {audio_path}")
    
    # 检查文件格式
    file_ext = Path(audio_path).suffix.lower()
    
    if file_ext in ['.wav', '.wave']:
        # 直接使用 WAV 文件
        wav_path = audio_path
        should_cleanup = False
    else:
        # 需要转换
        wav_path = convert_ogg_to_wav(audio_path)
        if not wav_path:
            print("音频转换失败")
            sys.exit(1)
        should_cleanup = True
    
    try:
        # 转录音频
        text = transcribe_audio(wav_path)
        
        if text:
            print("\n" + "="*60)
            print("转录结果:")
            print("="*60)
            print(text)
            print("="*60)
            
            # 保存结果到文件
            output_file = Path(audio_path).with_suffix('.txt')
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(text)
            print(f"结果已保存到: {output_file}")
            
            return text
        else:
            print("未能识别出文本")
            return None
            
    finally:
        # 清理临时文件
        if should_cleanup and wav_path and os.path.exists(wav_path):
            try:
                os.unlink(wav_path)
                print(f"已清理临时文件: {wav_path}")
            except:
                pass

if __name__ == "__main__":
    main()